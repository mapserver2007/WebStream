{
  "name": "Webstream",
  "tagline": "MVC+ServiceによるWebアプリケーションフレームワーク",
  "body": "# WebStream\r\nWebStreamはMVCアーキテクチャをベースとしたWebアプリケーションフレームワークです。  \r\nさらにS(Service)層を追加した4層構造のアーキテクチャとなっています。\r\n\r\n## WebStreamのアーキテクチャ\r\nWebStreamはMVCを拡張したアーキテクチャを採用しており、Serviceレイヤを追加しています。  \r\nMVCはFat Controller/Fat Model問題を引き起こしやすいアーキテクチャであるため、ビジネスロジックはServiceに定義します。  \r\nまた、View内でビジネスロジックを書く場合はHelperを利用し、Viewはレンダリングに専念させます。\r\n\r\n\r\n## [Controller](#controller)\r\nContollerではクライアントからのリクエストを受け付け、ServiceまたはModelを呼び出します。  \r\nControllerの処理が完了したらViewを呼び出します。Viewへパラメータを渡す場合、Serviceにセットします。  \r\n原則的にControllerにビジネスロジックを記述してはなりません。  \r\n`app/controllers`に`WebStream\\Core\\CoreController`クラスを継承したクラスを定義します。\r\n\r\n### Controllerクラスの定義\r\nControllerクラスは`\\WebStream\\Core\\CoreController`クラスを継承します。  \r\nControllerクラスからはServiceクラスまたはModelクラスを参照できます。またViewテンプレートを呼び出して描画できます。\r\n\r\n#### Serviceクラス、Modelクラス呼び出し\r\nServiceクラス、Modelクラスは以下のように呼び出します。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    public funciton execute()\r\n    {\r\n        // $this->{ページ名}->(Service|Modelクラスのメソッド)\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\nControllerクラス内の`$this->{ページ名}`オブジェクトにはServiceクラスまたはModelクラスのインスタンスが格納されています。  \r\nServiceクラスを定義している場合はServiceクラスインスタンスが格納されます。このときのページ名はアッパーキャメルケースで指定します。  \r\nServiceクラスを定義せずModelクラスのみ定義した場合はModelクラスインスタンスが格納されます。Serviceクラスに特段のビジネスロジックを記述する必要がなく、DBからのデータを取り出したいだけの場合など、Controllerクラスから直接Modelクラスにアクセスすることができます。  \r\nControllerクラスでは[アノテーション](#annotaion)を使ってメソッドやプロパティを操作できます。\r\n\r\n#### Viewテンプレート呼び出し\r\nHTMLを描画するにはControllerからViewテンプレートを呼び出します。Viewテンプレート呼び出しは[アノテーション](#annotaion)を利用します。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    /**\r\n     * @Template(\"index.tmpl\")\r\n     */\r\n    public funciton execute()\r\n    {\r\n        // $this->{ページ名}->(Service|Modelクラスのメソッド)\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\nこの処理で`@Template`に指定したテンプレートファイル`index.tmpl`を呼び出します。  \r\nテンプレートファイルは`app/views/(ページ名)/`に保存します。このときのページ名はスネークケースで指定します(詳細は[View](#view)で説明します)。\r\n\r\n\r\n## [Service](#service)\r\nServiceクラスではContollerクラスから受け取ったリクエストやデータを使って処理をしたり、View経由でビジネスロジックを実行します。  \r\nメインとなるビジネスロジックはServiceに記述します。データベースへの問い合わせが必要な場合はModelへ問い合わせます。  \r\nまた、Serviceでは開発者が個別に定義したクラス(ライブラリ)を利用することができます。Serviceで処理するロジックがない場合などはServiceを定義する必要はありません。  \r\n`app/services`に`WebStream\\Core\\CoreService`クラスを継承したクラスを定義します。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreService;\r\n\r\nclass BlogService extends CoreService\r\n{\r\n    public funciton entry()\r\n    {\r\n        // $this->{ページ名}->(Modelクラスのメソッド)\r\n        $this->Blog->getEntryData();\r\n    }\r\n}\r\n```\r\n\r\nServiceクラス内の`$this->{ページ名}`オブジェクトにはModelクラスのインスタンスが格納されています。ModelクラスにアクセスしてDB処理を実行します。  \r\nまた、ServiceクラスにはContoller、Service、Model、Helperの各クラスに属さないユーザ定義クラスへのパスが通っています。`app/libraries/`ディレクトリに任意のクラスを定義することでServiceクラスからアクセスできます。例えば、外部APIにアクセスするクラスや、データをバインドするEntityクラスなど特定用途のクラスはlibrariesに定義してください。\r\n\r\nServiceクラスは、Viewから参照されるデータを格納する**ViewModel**の機能を内包しています。  \r\nViewから参照するデータはServiceクラスのGetterメソッドを経由して参照することになりますが、データ量が多くなる場合、Getterメソッドとそれに使うプロパティが増えていきます。\r\nこれらはServiceの機能とは本質的には無関係な定義であるにもかかわらず、コード量として多くなってしまうため、Serviceでは`PropertyProxy`という機能を使い、簡単にViewModelを使えるようにしています。  \r\nServiceクラスの中で、未定義のプロパティに値をセットすると、PropertyProxyにより、Serviceクラス内で値が保持されます。保持されたデータはViewから参照可能になります。\r\nこれにより、Viewから参照するデータをGetterメソッドなしで参照でき、カプセル化した状態で値を保持することができます。\r\n\r\n**PropertyProxyを使わない場合**\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreService;\r\n\r\n// PropertyProxyなしの場合、Getterメソッドが必要\r\nclass BlogService extends CoreService\r\n{\r\n    // プロパティはpublicにすべきではない\r\n    private $title;\r\n\r\n    public function getTitle()\r\n    {\r\n        // ViewからはpublicなGetterメソッドでなければ参照不可\r\n        return $this->title;\r\n    }\r\n\r\n    public funciton entry()\r\n    {\r\n        $this->title = \"マイブログ\";\r\n    }\r\n}\r\n```\r\n\r\n```html\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\r\n  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"ja\" lang=\"ja\">\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\r\n    <head>\r\n        <title>%H{$model->getTitle()}</title>\r\n    </head>\r\n    <body>\r\n    </body>\r\n</html>\r\n```\r\n\r\n**PropertyProxyを使った場合**\r\n\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreService;\r\n\r\n// PropertyProxy使用の場合、Getterメソッドは不要\r\nclass BlogService extends CoreService\r\n{\r\n    public funciton entry()\r\n    {\r\n        $this->title = \"マイブログ\";\r\n    }\r\n}\r\n```\r\n\r\n```html\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\r\n  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"ja\" lang=\"ja\">\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\r\n    <head>\r\n        <title>%H{$model->title}</title>\r\n    </head>\r\n    <body>\r\n    </body>\r\n</html>\r\n```\r\n\r\nなお、定義済みのプロパティにセットした場合は、PropertyProxyは使われません。  \r\nまた、この機能はModelでも有効ですが、Serviceクラスを作る必要のない簡単な処理の場合以外はServiceクラスのViewModel機能を使うことを推奨します。\r\n\r\n## [Model](#model)\r\nModelクラスはControllerクラス、ServiceクラスまたはViewクラスからのリクエストや受け取ったデータを元にデータベースに問い合わせます。  \r\nServiceクラスが定義されない場合はController、Viewから直接呼び出されます。Modelにはデータベース問い合わせ処理を記述します。  \r\n`app/models`に`WebStream\\Core\\CoreModel`クラスを継承したクラスを定義します。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreModel;\r\n\r\n/**\r\n * @Database(driver=\"WebStream\\Database\\Driver\\Mysql\", config=\"config/database.mysql.ini\")\r\n */\r\nclass BlogModel extends CoreModel\r\n{\r\n    public funciton getEntryData()\r\n    {\r\n        $sql = \"SELECT * FROM T_Blog\";\r\n        return $this->select($sql);\r\n    }\r\n}\r\n```\r\n\r\n外部変数をパラメータに指定するには`$bind`変数にパラメータをセットします。\r\n`$bind`変数には連想配列でプリペアードステートメントに設定する値を指定します。\r\nデータベース接続設定はクラスに[アノテーション](#annotaion)を指定します。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreModel;\r\n\r\n/**\r\n * @Database(driver=\"WebStream\\Database\\Driver\\Mysql\", config=\"config/database.mysql.ini\")\r\n */\r\nclass BlogModel extends CoreModel\r\n{\r\n    public funciton getEntryData()\r\n    {\r\n        $sql = \"SELECT * FROM T_Blog WHERE id = :id\";\r\n        $bind = [\"id\" => 10];\r\n        return $this->select($sql, $bind);\r\n    }\r\n}\r\n```\r\n\r\nModelクラスでは以下のメソッドが利用可能です。\r\n\r\n#### Modelで利用可能なメソッド一覧\r\nメソッド                                                  |内容\r\n-------------------------------------------------------|----\r\nselect(string $sql)<br>select(string $sql, array $bind)|SELECTを実行する。\r\ninsert(string $sql, array $bind)                       |INSERTを実行する。\r\nupdate(string $sql, array $bind)                       |UPDATEを実行する。\r\ndelete(string $sql)<br>delete(string $sql, array $bind)|DELETEを実行する。\r\nbeginTransation(int $isolationLevel = 2)               |トランザクションを開始する。\r\ncommit()                                               |コミットする。\r\nrollback()                                             |ロールバックする。\r\nconnect()                                              |DBに接続する。\r\ndisconnect()                                           |DBを切断する。\r\n\r\n#### クエリファイルによるSQL実行\r\nModelクラスでは直接SQLをメソッド内に記述する以外に、クエリファイル(XML)を使ってSQLを実行できます。クエリファイルは`query/`に保存します。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!DOCTYPE mapper PUBLIC\r\n  \"-//github.com/mapserver2007//DTD Mapper 3.0//EN\" \"http://localhost/webstream-model-mapper.dtd\">\r\n<mapper namespace=\"MyBlog\">\r\n  <select id=\"getData\">\r\n    SELECT\r\n        *\r\n    FROM\r\n        T_Blog\r\n    WHERE\r\n        id = :id\r\n  </select>\r\n</mapper>\r\n```\r\nクエリファイルのDTDは同ディレクトリに配置し、DOCTYPEの値は適宜修正しDTDを指すようにします。  \r\nmapperタグの`namespace`にModelクラスの名前空間を指定します。名前空間が一致すればModelクラスからクエリファイルを呼び出すことができます。  \r\nmapperタグ配下にSQLを記述するタグを記述します。`<select>`、`<insert>`、`<update>`、`<delete>`タグが指定可能です。タグの`id`をModelクラスのメソッドからアクセスするとSQLを実行できます。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreModel;\r\n\r\n/**\r\n * @Database(driver=\"WebStream\\Database\\Driver\\Mysql\", config=\"config/database.mysql.ini\")\r\n */\r\nclass BlogModel extends CoreModel\r\n{\r\n    /**\r\n     * @Query(file=\"query/myblog.xml\")\r\n     */\r\n    public funciton getEntryData()\r\n    {\r\n        $bind = [\"id\" => 10];\r\n        return $this->getData($bind);\r\n    }\r\n}\r\n```\r\n#### クエリファイルによるSQL実行結果をエンティティクラスにマッピングする\r\nクエリファイルの`<select>`タグの`entity`属性にクラスパスを設定すると、取得結果をマッピングすることができます。  \r\nModelクラスでは直接SQLをメソッド内に記述する以外に、クエリファイル(XML)を使ってSQLを実行できます。クエリファイルは`query/`に保存します。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!DOCTYPE mapper PUBLIC\r\n  \"-//github.com/mapserver2007//DTD Mapper 3.0//EN\" \"http://localhost/webstream-model-mapper.dtd\">\r\n<mapper namespace=\"MyBlog\">\r\n  <select id=\"getData\" entity=\"\\MyBlog\\Entity\\BlogEntity\">\r\n    SELECT\r\n        title,\r\n        description\r\n    FROM\r\n        T_Blog\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n```php\r\nnamespace MyBlog\\Entity;\r\n\r\nclass BlogEntity\r\n{\r\n    private $title;\r\n    private $description;\r\n\r\n    public funciton getTitle()\r\n    {\r\n        return $this->title;\r\n    }\r\n\r\n    public funciton getDescription()\r\n    {\r\n        return $this->description;\r\n    }\r\n}\r\n```\r\n\r\nテーブルのカラム名とエンティティクラスのフィールド名には対応関係があり、それにしたがってマッピング定義する必要があります。  \r\nエンティティクラスのフィールド名はローワーキャメルケースで定義すると、型を含めてマッピングが実行されます。  \r\nテーブルのカラム名がスネークケースである場合、自動的に名前をローワーキャメルケースに変換した上でマッピングされます。カラム名がエンティティクラスのフィールド名にマッピングできない命名になっている場合、SQLのAS句で別名を付けて対応してください。\r\n\r\n#### 取得結果を配列にする\r\n`select`で取得した結果を配列に変換します。\r\n\r\n```php\r\n$this->select($sql, $bind)->toArray();\r\n```\r\n```php\r\n$this->getData($bind)->toArray();\r\n```\r\n\r\n#### 取得結果をエンティティにする\r\n`select`で取得した結果をエンティティに変換します。\r\n\r\n```php\r\n$entityClasspath = \"\\MyBlog\\Entity\\BlogEntity\";\r\n$this->select($sql, $bind)->toEntity($entityClasspath);\r\n```\r\n```php\r\n$entityClasspath = \"\\MyBlog\\Entity\\BlogEntity\";\r\n$this->getData($bind)->toEntity($entityClasspath);\r\n```\r\n\r\n[アノテーション](#annotaion)を使い、クエリファイルパスを指定します。これによりクエリファイルに記述したSQLが自動的に紐付けられます。\r\n\r\n#### トランザクション処理\r\n`$this->beginTransation()`でトランザクションを開始し`$this->commit()`でコミット、`$this->rollback()`でロールバックを実行します。  \r\nただし、DBMSがトランザクション処理に対応していない場合はトランザクション処理は有効になりません。  \r\nなお、トランザクション処理を明示しない場合、処理が終了後、自動的にコミットを実行します。  \r\n`$this->beginTransation()`はトランザクション分離レベルを引数として指定できます。  \r\n指定可能なトランザクション分離レベルは`Doctrine\\DBAL\\Connection`に定義されている値となります。\r\n\r\n## [View](#view)\r\nViewは画面に出力するHTMLなどを描画し、Controllerクラスから呼ばれます。HTML等の描画はWebStream独自のテンプレート機能を利用します。  \r\nViewからはHelperまたはModel、Serviceを呼び出してビジネスロジックを実行することができます。\r\n\r\nViewテンプレートはWebStream独自のBasicテンプレートとTwigテンプレートが使えます。\r\nBaicテンプレートファイルは`.tmpl`拡張子を、Twigテンプレートは`.twig`を付け、`app/views`にページ名をスネークケースに変換したフォルダを作成し保存します。  \r\n`__cache`、`__public`、`__shared`フォルダを作成すると、それぞれテンプレートキャッシュファイル、静的ファイル、共通テンプレートファイルを使用することができます。  \r\nViewにはModel/Serviceオブジェクトが渡されるので、Model、Serviceで取得した値やビジネスロジックの実行がViewで可能になります。  \r\nModel/Serviceオブジェクトは`$model`変数に格納されます。また、Helperオブジェクトは`$helper`変数に格納されます。\r\n\r\nContollerクラスからViewテンプレートを呼び出します。`@Template`の仕様は[アノテーション](#annotaion)を参照してください。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\n/**\r\n * テンプレートを呼び出す。\r\n * @Template(\"index.tmpl\")\r\n */\r\nclass BlogController extends CoreController\r\n{\r\n    public funciton execute()\r\n    {\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\n`__shared`に保存した共通テンプレートを呼び出すことができます。  \r\n共通点プレートはheaderやfooterなど共通になる部分を定義するときに使用します。  \r\n\r\nテンプレートを部品化したい場合、部分テンプレートとして呼び出すことができます。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\n/**\r\n * 基本テンプレートと共通テンプレートを呼び出す。\r\n * @Template(\"index.tmpl\")\r\n */\r\nclass BlogController extends CoreController\r\n{\r\n    public funciton execute()\r\n    {\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\nViewテンプレートにはHTMLを記述しますが、Service/Modelの値などを埋め込むことができます。\r\n\r\n```html\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\r\n  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"ja\" lang=\"ja\">\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\r\n    <head>\r\n        <title>%H{$model->getTitle()}</title>\r\n    </head>\r\n    <body>\r\n        <div>%H{$model->getContent()}</div>\r\n        %T{parts.tmpl}\r\n    </body>\r\n</html>\r\n```\r\n\r\n`$model`にアクセスするとServiceクラスまたはModelクラスにアクセスできます。また、`@Template`の`name`属性に指定した名前は変数としてアクセスできます。\r\n\r\n使用するテンプレートエンジンを明示する場合は以下のようにします。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\n/**\r\n * Basicテンプレートを使用する\r\n * @Template(\"index.tmpl\", engine=\"basic\")\r\n */\r\nclass BlogController extends CoreController\r\n{\r\n    public funciton execute()\r\n    {\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\n/**\r\n * Twigテンプレートを使用する\r\n * @Template(\"index.tmpl\", engine=\"twig\")\r\n */\r\nclass BlogController extends CoreController\r\n{\r\n    public funciton execute()\r\n    {\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\nBasicテンプレートにはテンプレートキャッシュ機能とCSRF対策トークン自動挿入機能がつきます。この機能により、CSRF対策が自動的に有効になります。  \r\nBasicテンプレートを指定している場合に`<form>`タグが含まれる場合、CSRF対策トークンが自動挿入されます。  \r\n(ただし、method=\"get\"の場合は有効になりません。)\r\n\r\n```html\r\n<head>\r\n<meta charset=\"utf-8\">\r\n<title>CSRF CHECK</title>\r\n</head>\r\n<body>\r\n<form action=\"/form_register\" method=\"post\">\r\n    <input type=\"button\" value=\"submit\">\r\n    <input type=\"hidden\" name=\"__CSRF_TOKEN__\" value=\"a2891f68edeb487a9140edf8575a8e3382f96c0d\">\r\n</form>\r\n</body>\r\n```\r\n\r\nフォームの送り先のControllerクラスで`@CsrfProtection`アノテーションを指定すると、CSRFチェック処理が実行されます。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    /**\r\n     * @CsrfProtection\r\n     */\r\n    public funciton formRegister()\r\n    {\r\n        // CSRFエラーがあった場合、例外が発生し、ここには到達しない\r\n    }\r\n}\r\n```\r\n\r\nCSRF対策トークンの送信はPOSTで通常行いますが、HTTPヘッダ`X-CSRF-Token`にトークン文字列を指定して送信することも可能です。\r\n\r\nテンプレートキャッシュ機能は、出力した内容をまるごとキャッシュする機能で、`cacheTime`属性で指定した時間(秒)だけキャッシュします。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    /**\r\n     * テンプレートキャッシュを600秒有効にする例\r\n     * @Template(\"index.tmpl\", engine=\"basic\", cacheTime=600)\r\n     */\r\n    public funciton execute()\r\n    {\r\n        $this->Blog->entry();\r\n    }\r\n}\r\n```\r\n\r\nViewテンプレートでは以下の構文が使用可能です。\r\n\r\n### [Viewテンプレート構文](#template_keyword)\r\n構文     |説明\r\n---------|----\r\n%P{$hoge}|%P{}で囲ったPHPのコードを実行する。関数を実行する場合などに使用する。<br>ただし、関数の実行結果をreturnしても画面表示されない。また、関数内部で`echo`で標準出力した場合はエスケープされないので注意。<br>実行結果を伴わない関数の実行が必要な場合に使用する。\r\n%H{$hoge}|%H{}で囲った変数を安全な値にエスケープしてHTMLとして表示する。関数を実行する場合も使用可能で、returnで返却された結果をエスケープして画面表示する。<br>ただし、関数内部で`echo`で標準出力した場合はエスケープされないので注意。\r\n%J{$hoge}|%J{}で囲った変数を安全な値にエスケープしてJavaScriptコードとして評価する。関数を実行する場合も使用可能で、returnで返却された結果をエスケープして画面表示する。<br>ただし、関数内部で`echo`で標準出力した場合はエスケープされないので注意。\r\n%X{$hoge}|%X{}で囲った変数を安全な値にエスケープしてXMLとして評価する。関数を実行する場合も使用可能で、returnで返却された結果をエスケープして画面表示する。<br>ただし、関数内部で`echo`で標準出力した場合はエスケープされないので注意。\r\n%T{$template}|%T{}で囲ったテンプレートパスを読み込む。\r\n\r\n## [Helper](#helper)\r\nViewの描画に関するロジックが必要な場合はHelperを呼び出します。  \r\nHelperクラスは`app/helpers`に`WebStream\\Core\\CoreHelper`クラスを継承したクラスを定義します。\r\n\r\n```php\r\nnamespace WebStream\\Test\\TestData\\Sample\\App\\Helper;\r\n\r\nuse WebStream\\Core\\CoreHelper;\r\nuse WebStream\\Core\\CoreService;\r\n\r\nclass TestHelperHelper extends CoreHelper\r\n{\r\n    public function help1()\r\n    {\r\n         return $this->help2($model->getName());\r\n    }\r\n}\r\n```\r\n\r\nHelperクラス内ではViewテンプレート内と同様に`$model`オブジェクトからModelクラス、Serviceクラスを呼び出すことができます。  \r\nHelperクラスのメソッドは`$helper`オブジェクトにより呼び出します。\r\n\r\n```php\r\n$helper->method();\r\n```\r\n\r\nメソッド呼び出しにより、Viewテンプレートで必要なロジックを実行します。  \r\nメソッドの戻り値はViewテンプレートに描画されますが、<a href=\"#template_keyword\">Viewテンプレート構文</a>によりエスケープして出力し、安全な値として出力する必要があります。\r\n\r\n```php\r\n%H{$helper->method()}\r\n```\r\n\r\nただし、Helper内で直接echoで出力するとエスケープされないので注意してください。\r\n\r\n## [命名規則まとめ](#naming_rule)\r\n各クラスの命名規則、保存場所のまとめは以下のとおりです。\r\n\r\nレイヤ      |サンプルクラス名    |保存場所\r\n----------|----------------|------\r\nController|SampleController|app/controllers/SampleController.php\r\nService   |SampleService   |app/services/SampleService.php\r\nModel     |SampleModel     |app/models/SampleModel.php\r\nView      |(任意の名前).tmpl|app/views/sample/(任意の名前).tmpl\r\nHelper    |SampleHelper    |app/helpers/SampleHelper.php\r\n\r\n上記レイヤに乗らない、開発者が独自に定義したいクラスを格納する階層を作成することができます。\r\n\r\nレイヤ      |サンプルクラス名    |保存場所\r\n----------|----------------|------\r\n独自レイヤ  |(任意の名前)     |app/(任意の場所)/(任意の名前).php\r\n\r\nエンティティマッピングで使用するエンティティクラスや外部APIを利用するためのクラスなどはここに定義します。\r\n\r\n## [ルーティング定義](#routing)\r\n### routes.yml\r\nルーティング設定により、URI設計を行うことができます。ルーティングにはmod_rewiteが必要です。  \r\nルーティング定義は`config/routes.yml`に記述します。\r\n\r\n```yml\r\n'/login': 'sample#login'\r\n'/blog/:id': 'blog#entry'\r\n```\r\n\r\nキーにURIパス定義、バリューにクラス、アクション定義を記述します。誤った定義が記述された場合、例外が発生します。\r\n\r\n### URIパス定義\r\nURIパスは`/path/to`形式で定義します。またURIには変数の設定が可能で、`:value`形式で記述します。例えば、`/blog/:id`と定義し、`/blog/10`にアクセスした場合、Controllerクラスでは以下の方法で値を取得出来ます。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    public function execute(array $params)\r\n    {\r\n        $id = $params['id']; // 10\r\n    }\r\n}\r\n```\r\n\r\n## [バリデーション定義](#validate)\r\nControllerクラスのアクションメソッドに`@Validate`アノテーションを記述することでバリデーションを有効にできます。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\nuse WebSteram\\Annotation\\Validate;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    /**\r\n     * GETリクエストのtestパラメータの指定がない場合、エラーになる例\r\n     * @Validate(key=\"test\", rule=\"required\", method=\"get\")\r\n     */\r\n    public function execute()\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nバリデーションルールは以下のものが用意されています。\r\n\r\n####バリデーションチェックルール\r\n\r\nルール        |内容\r\n-------------|---------\r\nrequired     |必須チェック\r\nnumber       |数値チェック(整数)\r\nmin[n]       |最小値チェック(整数)\r\nmax[n]       |最大値チェック(整数)\r\nmin_length[n]|最小文字数チェック(整数)\r\nmax_length[n]|最大文字数チェック(整数)\r\nequal        |文字列一致チェック\r\nlength       |文字数一致チェック\r\nrange[n..m]  |範囲チェック(整数)\r\nregexp[//]   |正規表現チェック\r\n\r\n### カスタムバリデーション\r\n用意されているバリデーションルール以外に、開発者が独自にルールを定義することが出来ます。  \r\n`app`ディレクトリ配下の任意の場所にバリデーションクラスを作成します。\r\n\r\n```php\r\nnamespace Blog;\r\n\r\nuse WebStream\\Validate\\Rule\\IValidate;\r\n\r\nclass Page implements IValidate\r\n{\r\n    public function isValid($value, $rule)\r\n    {\r\n        return $value === null || (bool) preg_match('/^[1-9]{1,}[0-9]{0,}$/', $value);\r\n    }\r\n}\r\n```\r\n\r\n`WebStream\\Validate\\Rule\\IValidate`インタフェースを実装し、戻り値が`bool`型の`isValid`メソッドを実装します。  \r\nバリデーションが成功すればtrue、失敗すればfalseを返すようにします。  \r\nクラス名がルール名と紐付いているので、`@Validate`アノテーションに指定します。  \r\nただし、ルール名はクラス名をスネークケースに変換したものになります。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\nuse WebSteram\\Annotation\\Validate;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    /**\r\n     * @Validate(key=\"p\", rule=\"page\", method=\"get\")\r\n     */\r\n    public function execute()\r\n    {\r\n    }\r\n}\r\n```\r\n\r\n## [リクエストパラメータ](#request)\r\nGET/POST/PUT/DELETEで送信した値をControllerで取得できます。  \r\n`$this->request`オブジェクトからリクエストパラメータを取得でき、`get`,`post`,`put`,`delete`メソッドにそれぞれアクセスします。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass BlogController extends CoreController\r\n{\r\n    public function execute()\r\n    {\r\n        $getParams = $this->request->get(); // GETパラメータすべて取得\r\n        $getParam  = $this->request->get(\"name\");\r\n    }\r\n}\r\n```\r\n\r\n## [セッション](#session)\r\nログイン処理などを実装するときに、セッション管理を使用しますが、WebStreamでは`$this->session`オブジェクトを使用します。セッション期限を指定するには`restart`メソッドを使用します。\r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass LoginController extends CoreController\r\n{\r\n    public function execute()\r\n    {\r\n        $expire = 6000; // 10分\r\n        $path = \"/login\";\r\n        $domain = \".mydomain.com\";\r\n        $getParams = $this->session->restart($expire, $path, $domain);\r\n    }\r\n}\r\n```\r\n\r\nセッションがタイムアウトした場合、`SessionTimeoutException`が発生します。\r\n\r\n## [キャッシュ](#cache)\r\nキャッシュ機能を使うことができます。使用できるキャッシュライブラリは以下のとおりです。\r\n\r\n| クラス        | 出力先                       | 設定方法                                           |\r\n|---------------|------------------------------|----------------------------------------------------|\r\n| Apcu          | APCuキャッシュを使用する     | APCuをインストールする                             |\r\n| Memcached     | memcachedを使用する          | memcachedをインストールする config/cache.ymlに設定 |\r\n| Redis         | redisを使用する              | redisをインストールする config/cache.ymlに設定     |\r\n| TemporaryFile | ファイルキャッシュを使用する | 利用時に出力先を指定する                           |\r\n\r\nキャッシュは`CacheDriverFactory`クラスを使うことで簡単に使用できます。  \r\n\r\n```php\r\nuse WebStream\\Module\\Container;\r\nuse WebStream\\Cache\\Driver\\CacheDriverFactory;\r\n\r\n$factory = new CacheDriverFactory();\r\n$config = new Container(false);\r\n$config->cachePrefix = \"test_cache\";\r\n$cache = $factory->create(\"WebStream\\Cache\\Driver\\Apcu\", $config);\r\n$cache->inject('logger', $this->logger);\r\n\r\n$cache->add(\"key\", \"value\");\r\n$value = $cache->get(\"key\");\r\n```\r\n\r\nさらに簡単に使うためのUtilityが用意されているので、それを使うとより簡潔に書くことができます。  \r\n\r\n```php\r\nuse WebStream\\Module\\Utility\\CacheUtils;\r\n\r\n$cache = $this->getCacheDriver(\"apcu\", \"test_cache\");\r\n$cache->inject('logger', $this->logger);\r\n\r\n$cache->add(\"key\", \"value\");\r\n$value = $cache->get(\"key\");\r\n```\r\n\r\nキャッシュライブラリとして使う場合の接続先情報は`config/cache.yml`に設定を書く必要があります。  \r\n`cache.yml`のサンプルは以下のとおりです。\r\n\r\n```yml\r\n---\r\n  memcached:\r\n    host: 192.168.1.100\r\n    port: 11211\r\n  redis:\r\n    host: 192.168.1.100\r\n    port: 6379\r\n  temporaryfile:\r\n    path: \"/tmp\"\r\n```\r\n\r\n## [ロギング](#logging)\r\n### ログ設定\r\n`config/log.ini`または`config/log.yml`を配置し、ログ設定を記述します。  \r\nログ格納ディレクトリには書き込み権限を与えておく必要があります。  \r\n\r\n```\r\n; プロジェクトルートからの相対パスまたは絶対パス\r\npath = log/webstream.log\r\n; ログレベル\r\nlevel = debug\r\n; ログローテート設定(day|month|year)\r\nrotate_cycle = day\r\n; ログローテート設定(サイズ:Byte)\r\nrotate_size = 1024\r\n; ログに表示するアプリケーション名\r\napplicationName = webstream\r\n; ログフォーマット設定\r\n; 設定しない場合はデフォルト設定になる\r\n; %c ログに表示するアプリケーション名\r\n: %d 日付(%Y-%m-%d %H:%M)\r\n; %d{(指定フォーマット)} 日付 例：%d{%Y-%m-%d %H:%M.%f}\r\n; %l ログレベル(小文字)\r\n; %L ログレベル(大文字)\r\n; 表示幅指定 例：%5L → [INFO ]、[DEBUG]など\r\n;   表示幅指定は%c、%l、%L、%dに適用可\r\n; %m ログメッセージ\r\nformat = [%c][%d{%Y-%m-%d %H:%M:%S.%f}][%5L] %m\r\n```\r\n\r\nController、Service、Model、Helperクラスでロガーを使用できます。  \r\n\r\n```php\r\nnamespace MyBlog;\r\n\r\nuse WebStream\\Core\\CoreController;\r\n\r\nclass LoginController extends CoreController\r\n{\r\n    public function index()\r\n    {\r\n        $this->logger->debug(\"logging in controller\");\r\n    }\r\n}\r\n```\r\n\r\nログレベルについては、[PSR-3](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md)に準拠しています。\r\n\r\n### ロガーのカスタマイズ\r\nデフォルトではロガーはログファイル出力しますが、Outputterを切り替えることで出力先を変更することができます。  \r\nロガーインスタンスを新たに生成し、Outputterを差し替えます。\r\n\r\n```\r\n$instance = Logger::getInstance();\r\n$instance->setOutputter([\r\n   new BrowserOutputter()\r\n]);\r\n$customLogger = new LoggerAdapter($instance);\r\n```\r\n\r\nWebStream標準では以下のOutputterが用意してあります。独自に定義すれば出力先を自由に変えることができます。  \r\n\r\n| Outputter種類    | 出力先                     |\r\n|------------------|----------------------------|\r\n| FileOutputter    | 指定したログファイルに出力 |\r\n| BrowserOutputter | ブラウザに出力             |\r\n| ConsoleOutputter | コンソールに出力           |\r\n\r\n### ログの遅延書き込み機能\r\nキャッシュ機能が有効になっている場合、ログは一旦キャッシュに保存され、すべての処理終了後にまとめてログファイルに出力されます。  \r\nキャッシュは`APCu`、`Memcached`、`Redis`のいずれかが使用可能です(デフォルトはAPCu)。  \r\nこれらのキャッシュライブラリが使用不可の場合はキャッシュせず即時ログ出力を行いますが、パフォーマンス上あらかじめキャッシュライブラリをインストールしておくことを推奨します。\r\n\r\n## [ファイル入出力](#io)\r\nPHP標準の`file`、`file_get_contents`、`file_put_contents`などを使うとファイル入出力ができますが、WebStreamでは安全にファイル入出力を行うためのクラスが用意してあります。  \r\n\r\n| クラス           | 内容                                                                                                       |\r\n|------------------|------------------------------------------------------------------------------------------------------------|\r\n| FileReader       | ファイル読み込みを行う<br>ファイルはロックしない                                                           |\r\n| FileWriter       | ファイル書き込みを行う<br>書き込み時に排他ロックを取得する<br>ファイルを閉じるまでロックし続ける           |\r\n| SimpleFileWriter | ファイル書き込みを行う<br>書き込み時に排他ロックを取得する<br>書き込む度にファイルを閉じてロックを解放する |\r\n\r\nこれらのクラスはファイルの読み込みや書き込みになんらかの問題が発生した場合、`IOException`をスローするので、適切に例外処理することができます。  \r\nさらに以下のクラスを使うことで、ファイルオブジェクトを取得することができます。それにより、さらに高度なファイル処理が可能になります。  \r\n\r\n| クラス             | 内容                                               |\r\n|--------------------|----------------------------------------------------|\r\n| InputStreamReader  | ファイル読み込みを行う<br>入力ストリームを操作可能 |\r\n| OutputstreamWriter | ファイル書き込みを行う<br>出力ストリームを操作可能 |\r\n\r\n## [アノテーション](#annotation)\r\nControllerとModelではアノテーションを使ってクラスやメソッドを操作することができます。アノテーションを利用することで便利な処理が可能になります。  \r\n\r\nアノテーションを適用するクラスは`IAnnotatable`を実装する必要があります。  \r\n例えば`app/libraries/`に独自で定義したクラスには開発者が`IAnnotatable`を実装しないと、アノテーションが有効になりません。  \r\nなお、Controller、Service、Model、Helperの各クラスはデフォルトで実装されているため改めて開発者が実装する必要はありません。\r\n\r\n#### すべてのレイヤで使用可能なアノテーション\r\nアノテーション      |説明                                         |サンプル\r\n-----------------|---------------------------------------------|------\r\n@Autowired       |プロパティに対するアノテーションを有効にする         |@Autowired(value=\"hoge\")<br>@Autowired(type=\"\\Hoge\")\r\n@Alias           |指定されたメソッド名で受けてアノテーションが定義されたメソッドへ転送する |@Alias(name=\"aliasMethod\")\r\n@Filter          |メソッドが呼ばれる前または後に任意の処理を実行する    |@Filter(type=\"before\")<br>@Filter(type=\"after\")<br>@Filter(type=\"before\" except=\"method1\")<br>@Filter(type=\"before\" only=\"method2\")<br>@Filter(type=\"before\",only=\"method1\",except=\"method2\")<br>@Filter(type=\"after\",except={\"method1\",\"method2\"})\r\n\r\n#### Controllerで使用可能なアノテーション\r\nアノテーション     |説明                                         |サンプル\r\n-----------------|---------------------------------------------|------\r\n@Header          |リクエスト/レスポンスを制御する                       |@Header(contentType=\"html\")<br>@Header(contentType=\"xml\")<br>@Header(allowMethod=\"POST\")<br>@Header(allowMethod={\"GET\",\"POST\"})\r\n@Template        |Viewテンプレートを設定する                         |@Template(\"index.tmpl\")<br>@Template(\"index.tmpl\",name=\"head\" type=\"parts\")<br>@Template(\"index.tmpl\",name=\"shared\",type=\"shared\")\r\n@ExceptionHandler|例外を補足して別処理を実行する                     |@ExceptionHandler(\"\\Exception\")<br>@ExceptionHandler({\"\\RuntimeException\",\"\\LogicException\"})\r\n@CsrfProtection  |CSRF対策処理を実行する                          |@CsrfProtection\r\n\r\n#### Modelで使用可能なアノテーション\r\nアノテーション |説明                                 |サンプル\r\n-------------|------------------------------------|---------------------------------------------------------------------------------------\r\n@Database    |Modelクラスに対してデータベース設定をする|@Database(driver=\"WebStream\\Database\\Driver\\Mysql\", config=\"config/database.mysql.ini\")\r\n@Query       |読み込むクエリファイルを指定する         |@Query(file=\"query/blog_query.xml\")\r\n\r\n### カスタムアノテーション\r\n用意されているアノテーション(デフォルトアノテーション)以外に独自のカスタムアノテーションを定義することができます。\r\n\r\n#### 定義方法\r\n`app`ディレクトリ以下の任意の場所にクラスを定義します。定義したクラスは自動的にクラスパスが通ります。  \r\nクラスの定義は以下のルールに従って定義してください。\r\n\r\nNo |ルール                                      |内容                                                       |必須かどうか\r\n---|-------------------------------------------|-----------------------------------------------------------|-------------------\r\n1  |`@Annotation`、`@Target`をクラスにアノテート  |Doctrine Annotationを使用する                               |必須\r\n2  |`\\WebStream\\Annotation\\Annotation`を継承    |アノテーション処理実行可能なクラスにする                        |必須\r\n3  |`Annotation#onInject`を実装する             |アノテーション初期処理を実行                                   |必須\r\n4  |`IClass`を実装する                          |クラスに対するアノテーションを実行する                          |任意\r\n5  |`IClass#onClassInject`を実装する            |クラスに対するアノテーションを実行したときに呼ばれる              |IClass実装時は必須\r\n6  |`IMethod`を実装する                         |実行するメソッド(アクションメソッド)に対するアノテーションを実行する|任意\r\n7  |`IMethod#onMethodInject`を実装する          |メソッド(アクションメソッド)に対するアノテーションを実行する       |IMethod実装時は必須\r\n8  |`IMethods`を実装する                        |すべてのメソッドに対するアノテーションを実行する                  |任意\r\n9  |`IMethods#onMethodInject`を実装する         |すべてのメソッドに対するアノテーションを実行する                  |IMethods実装時は必須\r\n10 |`IProperty`を実装する                       |すべてのプロパティに対するアノテーションを実行する                |任意\r\n11 |`IProperty#onPropertyInject`を実装する      |すべてのプロパティに対するアノテーションを実行する                |IProperty実装時は必須\r\n12 |`IRead`を実装する                           |アノテーション処理実行後、任意のデータを返却する処理を実行         |任意\r\n13 |`IRead#onInjected`を実装する                |任意のデータを返却する                                        |IRead実装時は必須\r\n\r\nデフォルトアノテーションは使用できるレイヤが制限されていますが、カスタムアノテーションはController/Service/Modelレイヤで使用可能です。\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}